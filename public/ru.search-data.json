{"/blog/eventloop/":{"data":{"":"Эта статья начинает цикл статей про параллельное программирование в Dart.\nВесь Dart-код выполняется в изолятах. Сначала запускается основной изолят, и опционально количество изолятов можно расширить, создав их явно. Каждый изолят имеет собственную изолированную память и свой цикл событий (Event Loop). Благодаря именно циклу событий можно асинхронно выполнять различные операции.\nПосле запуска приложений инициализируется две очереди: Очередь событий (Event Queue) и очередь микрозадач (Microtask Queue).\nОчередь событий может содержать как любые события: ввод-вывод, нажатия клавиш, запросы на перерисовку пользовательского интерфейса, сообщения между изолятами и т. д. Приложение не может предсказать в каком порядке произойдут события, поэтому они обрабатываются по одному за раз, в порядке постановки их в очередь. Чтобы добавить элемент в эту очередь используется класс Future.\nОчередь микрозадач используется для коротких действий, которые нужно выполнять асинхронно, сразу после завершения какого-либо события и перед тем, как управление не перейдет в очередь событий. Эта очередь обрабатывается первой и до тех пор, пока не будут выполнены все микрозадачи. Чтобы добавить микрозадачу в эту очередь можно использовать именованный конструктор Future.microtask или функцию верхнего уровня scheduleMicrotask.\nСвою работу цикл событий начинает после выхода потока управления из функции main. То есть сначала будут выполнены все синхронные задачи в этой функции. Если будут встречаться асинхронные вызовы, то они будут помещаться в соответствующие очереди.\nРаботу цикла можно описать следующими шагами:\nВыполняются микрозадачи в порядке их нахождения в очереди микрозадач. Обрабатывается первый элемента в очереди событий. Повторение цикла Если обе очереди пусты и больше не ожидается событий, то приложение завершается. Обычно при планировании отложенных задач лучше использовать Future, потому что это поможет сохранить короткую очередь микрозадач, уменьшая вероятность, что из-за нее будет простаивать цикл событий."},"title":"Dart: Event Loop"},"/blog/future/":{"data":{"async-и-await#async и await":"Ключевые слова async и await предоставляют декларативный способ определения асинхронных функций и использования их результатов. Есть два основных правила:\nЧтобы определить асинхронную функцию, нужно добавить async перед телом функции. Ключевое слово await работает только в асинхронных функциях. Результатов функции, помеченной async является Future.\nFuture\u003cString\u003e getAsyncGreeting() async { await Future.delayed(Duration(seconds: 2)); return \"Hello, World!\"; } Асинхронная функция выполняется синхронно до первого ключевого слова await. Это означает, что в теле асинхронной функции весь синхронный код до первого ключевого слова await выполняется немедленно.\nFuture\u003cvoid\u003e printAsyncGreeting() async { print(\"Hi!\"); await Future.delayed(Duration(seconds: 2), () =\u003e print(\"Hola!\")); print(\"Hallo!\"); } Отлавливать ошибки можно с помощью привычного try-catch-finally.\ntry { greeting = await getAsyncGreeting(); priint(greeting); } catch (e) { // handle error } На самом деле async и await являются надстройками над Feature API.\nЧтобы выявить распространенные ошибки, возникающие при работе с асинхронностью то можно включить следующие проверки линтера:\ndiscarded_futures unawaited_futures ","future-api#Future API":" Photo by Aren Nagulyan on Unsplash\nВ отличие от синхронной операции, асинхронная не может предоставить результат немедленно. Асинхронной операции может потребоваться дождаться выполнения других внешних операций (Например, выполнения сетевого запроса). Вместо блокировки потока, асинхронная операция немедленно возвращает объект типа Future, который представляет собой результат этой операции. Он может иметь два состояния: завершенное и незавершенное.\nНезавершенный future ожидает завершения асинхронной операции или выдачи ошибки.\nПри успехе future типа Future\u003cT\u003e завершается со значением типа T. Если future не возвращает значения для дальнейшего использования, то ее тип Future\u003cvoid\u003e. Если асинхронная операция завершается неудачей, то future завершается с ошибкой.\nЕсли нужно получить результат Future, то для этого есть два пути:\nИспользовать Future API async / await Future APIДля каждого состояния Future можно зарегистрировать обратные вызовы then(onValue) для обработки значения и catchError(), для обработки ошибок, возникающих во время выполнения операции и в then().\nmyAsyncFunc().then(processValue).catchError(handleError); Цепочка из then() и catchError() может рассматриваться как грубый эквивалент try-catch\nFuture может иметь больше одной пары зарегистрированных обратных вызовов. Каждый последующий объект обрабатывается независимо и так, как если бы он был единственным.\nС помощью catcError() можно обрабатывать специфичные ошибки. Для этого есть необязательный именованный параметр test, где можно выполнить проверку на определенный тип ошибки\nmyAsyncFunc() .then((_) =\u003e ...) .catchError(handleExceptionOne, test: (e) =\u003e e is ExceptionOne) .catchError(handleExceptionTwo, test: (e) =\u003e e is ExceptionTwo); Помимо catchError() можно зарегистрировать обратный вызов onError(), но в отличие от первого, он обрабатывает ошибки, возникающие в then()\nТак же можно определить обратный вызов whenComplete(), это эквивалент finally в try-catch-finally. Он вызывается, когда завершается его приемник, независимо от того, делает он это со значением или ошибкой.\nmyAsyncFunc() .then(processValue) .catchError(handleError) .whenComplete(() =\u003e print(\"I work in any case\")); Если в whenСomplete() не появляется ошибка, то его Future завершается так же, как Future, на котором он был вызван."},"title":"Dart: Future"}}